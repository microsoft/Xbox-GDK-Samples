![](./media/image1.png)

# Meshlet インスタンス化のサンプル

*このサンプルは、Microsoft Game Development Kit (2022 年 3 月) および Windows 10 (バージョン 2004) 2020 年 5 月の更新プログラムと互換性があります*

# 説明

メッシュ シェーダー パイプラインによって、入力アセンブラーが作成されます。これは、インデックスの処理とインスタンス化の機能を実行します。 このため、メッシュ シェーダー パイプラインでは、従来のグラフィックス パイプラインのようにインスタンス化のための高レベルのインターフェイスは公開されません。代わりに、開発者はメッシュ シェーダー スレッド ID を使用して独自のインスタンス化ソリューションを実装する責任を負います。

GPU は、*ウェーブ*と呼ばれる、固定サイズのスレッドのチャンクでワークロードをディスパッチします。 このサイズはアーキテクチャ固有ですが、ディスパッチできるスレッドの最小量です。 入力アセンブラーが実行した機能の 1 つは、これらのウェーブを処理して、スレッド使用率を最適化することでした*。 ウェーブ使用率* は、実際のデータを処理しているウェーブ スレッドと、ディスパッチされたウェーブの合計数の比率です。

メッシュ シェーダー パイプラインでは入力アセンブラーの使用が省略されるため、ウェーブを作業でパックするという懸念が開発者に課せられます。 メッシュレットは、ウェーブの利用を最適化する、メッシュを使いやすいサイズの作業チャンクに前処理するツールです。 ただし、メッシュレットには完全に満たされているという厳しい制約がないため、ウェーブの利用が最適化されていません。 具体的には、メッシュの最後のメッシュレットはおそらくいっぱいではありません (メッシュが満たされる前にプリミティブが使い果たされたため)。 メッシュ内のメッシュレットの数がゼロに近づくにつれて、この問題はますます大きくなります。 これらの小さなメッシュの重いインスタンス化は、葉、髪、粒子などでよく見られます。

このサンプルでは、最後に未充填のメッシュレットの多数のインスタンスを 1 つのスレッドグループにパックすることにより、効率的にインスタンス化する一般化された方法を示します。 これにより、ウェーブ使用率が 100% に非常に近い状態で、ディスパッチされるデッド スレッドの数が最小限に抑えられます。

![](./media/image3.png)

# サンプルのビルド

Xbox Series X|S 開発キットを使用している場合は、アクティブ ソリューション プラットフォームを `Gaming.Xbox.Scarlett.x64` に設定します。

適切なハードウェアと Windows 10 または Windows 11 リリースで PC を使用する場合は、アクティブなソリューション プラットフォームを Gaming.Desktop.x64 に設定します。

このサンプルでは、Xbox One はサポートされていません。

*詳細については、**GDK ドキュメント*の「__サンプルの実行__」 を参照してください。

# サンプルの使用方法

サンプルでは、同心円と立方体の 2 つのインスタンス レイアウトから選択するオプションが提供されます。 これにより、さまざまなレートでスケーリングできます。 フラット シェーディングを切り替えたり、インスタンスの基になるメッシュレット構造を視覚化したりすることもできます。

# Controls

| 操作 | ゲームパッド | キーボード |
|---|---|---|
| カメラを移動する | 左サムスティック | WASD キーまたは方向キー |
| カメラを回転させる | 右サムスティック | LMB + マウスを長押しする |
| カメラを再設定 | 右サムスティック (プッシュ) | \- |
| インスタンス化モードの変更 | A | Tab |
| メッシュレットの視覚化を切り替える | X | Space キー |
| インスタンス化レベルを上げる | 右肩 | \+ |
| インスタンス化レベルを下げる | 右トリガー | \- |
| Exit | ビュー ボタン | Esc キー |

# 実装メモ

メッシュ シェーダーのインスタンス化は、作業を完了するのに十分なシェーダー インスタンスをディスパッチし、指定された ID を使用して、処理する正しいメッシュレットとインスタンスを決定する単純な問題です。 選択したインデックス作成スキームによって、どのスレッド グループがどのビットの作業を処理するかを決定します。

スレッド グループごとに 1 つのメッシュレットがあると仮定すると、最も簡単な実装は MeshletCount \* InstanceCount スレッド グループをディスパッチすることです。 これは、ワークロードを完全に処理するのに十分なスレッド グループであると確信できます。 これは、非常に簡単なインデックス作成スキームも提供します:

- *MeshletIndex* = *GroupID.x* / *InstanceCount*

- *InstanceIndex* = *GroupID.x* % *InstanceCount*

これは、最初の *InstanceCount* スレッド グループはすべて Meshlet *0* を処理しますが、異なるインスタンスを処理することを意味します。 さらに重要なのは、最後の *InstanceCount* スレッド グループがすべて Meshlet *(MeshletCount -- 1)* を処理することです。 最初の *(MeshletCount -- 1)* メッシュレットは 'full' (最大に近い頂点および/またはプリミティブを持つ) であり、最後のメッシュレットはそれほど満たされていないと仮定します。 したがって、最後の *(MeshletCount -- 1)* スレッド グループは、最初の *(MeshletCount -- 1) \* InstanceCount* スレッド グループよりも最適なウェーブ使用率が低くなります。 十分にまばらであれば、複数のインスタンスを 1 つのスレッド グループにパックできます。

実際、スレッド グループ サイズが最大メッシュレット サイズと等しいと仮定すると、$\lfloor MaxMeshletSize\ /\ LastMeshletSize\rfloor$ インスタンスを 1 つのスレッド グループに収めることができます。 したがって、最後のメッシュレットを処理するには $\lfloor(LastMeshletSize*InstanceCount)/MaxMeshletSize\rfloor$ パックされたスレッド グループが必要です。 これにより、シェーダー内のこれらのスレッド グループの追加 ALU をコストにして、最適なウェーブ効率が提供されます。

# 更新履歴

2019 年 10 月 31 日 -- サンプル作成。

2020 年 4 月 28 日 - メッシュ シェーダー パイプラインの作成に D3DX12 ヘルパーを使用するように更新済み

# プライバシーに関する声明

サンプルをコンパイルして実行する場合、サンプルの使用状況を追跡するために、サンプルの実行可能ファイルのファイル名が Microsoft に送信されます。 このデータ コレクションからオプトアウトするには、Main.cpp の "サンプル使用状況テレメトリ" というラベルの付いたコードのブロックを削除します。

Microsoft のプライバシー ポリシー全般の詳細については、「[Microsoft のプライバシーに関する声明](https://privacy.microsoft.com/en-us/privacystatement/)」を参照してください。


