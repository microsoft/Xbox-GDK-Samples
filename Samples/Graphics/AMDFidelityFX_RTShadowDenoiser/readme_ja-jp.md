  ![](./media/image1.png)![](./media/image3.png)

#   FidelityFX レイトレーシング シャドー デノイザーサンプル

*このサンプルは Microsoft Game Development Kit (2021 年 2 月)
と互換性があります*

# 説明

# この例では、DXR 1.0 レイトレーシング シャドーの基本的な実装に対して適用される FidelityFX RT Shadow デノイザーの実装を示します。

![](./media/image4.jpeg)

# サンプルのビルド

Windows デスクトップを使用している場合には、アクティブ ソリューション
プラットフォームを Gaming.Desktop.x64 に設定します。

Project Scarlett を使用している場合は、アクティブ ソリューション
プラットフォームを Gaming.Xbox.Scarlett.x64 に設定します。

このサンプルは、Xbox One と互換性があります。

*詳細については、GDK
のドキュメントの*「サンプルの実行」*を参照してください。*

# サンプルの使用方法

| 操作                                  |  ゲームパッド                 |
|---------------------------------------|------------------------------|
| ビューの回転                          |  左サムスティック             |
| ビューのリセット                      |  左サムスティック (クリック)  |
| 終了                                  |  ビュー ボタン                |

# 実装上の注意

このサンプルにはレイトレーシング シャドウの基本的な単一ポイント
ライト実装があり、コーン内の光線ランダム化を使用して半影を実現します。本質的にノイズの多いプロセスであり、パフォーマンス上の理由から、ピクセル
あたり 1
光線を超えないようにするため、運用環境でノイズ除去を使用する必要があります。

RT
シャドウの実装は、このサンプルの焦点ではなく、単にデノイザーに入力される方法
で最適化されていません。

FidelityFX Raytraced Shadow デノイザー
はレイトレーシングからノイズの多い出力を受け取り、複数のパスを介してシャドウを分類し、シーンに合成するために許容されるフォームにフィルター処理します。

![](./media/image5.png)

ノイズの多い RT シャドウ

![](./media/image6.png)

影の除去

## パス

**ffx_denoiser_shadows_prepare**

まず、レイトレーシングからの出力は、8x4 ピクセル領域を表すために uint
ビットマスクにレイアウトされたバッファーにパックされます。これは、後のパスでの帯域幅の削減に役立ちます。レイトレーシング
パスがグループとして機能し、これらのビットマスクを直接書き込む最適化を行うことができますが、これはこのサンプルでは実行されません。

**ffx_denoiser_shadows_tileclassification**

タイル分類は、実際には 3 つの主要な手順を実行します。

1.  Local Neighborhood

2.  分離マスク

3.  再投影

**Local Neighborhood** は、ピクセルを囲むシェーディング値
(この場合はノイズの多いシャドウ値) の最初の 2
つの瞬間をエンコードします。

これらの瞬間はそれぞれ呼び出されます。

-   **平均** (隣接するサンプルの平均)

-   と
    **分散**を意味します。これは、画像内のノイズの量の推定を表します。

これらの値は再投影手順で使用されるため、後で使用方法を確認します。ここでは、計算方法に焦点を当てます。

FidelityFX RT Shadow デノイザー は、カーネル半径の値を 8
に設定します。これは 17x17 カーネルに対応します。

大きな影の動きの下でさまざまなカーネル
サイズを持つ一連のレンダリングを次に示します。

| ![](./media/image    | ![](./media/imag      | ![](./media/imag      | | 7.png){width="2.0in" | e8.png){width="2.0in" | e9.png)       |
| > 5x5 カーネル  |  > 17x17 カーネル > (既定) |  > 29x29 カーネル |
|----------------------|-----------------------|-----------------------|
|  |

カーネルのサイズに応じてシャドウの品質がどのように向上するかを確認できます。17x17
カーネルは、品質とパフォーマンスのバランスとして選択されます。

ただし、17x17 カーネルでは、ピクセルあたり 289
タップが必要になります。これは非常にコストがかかります。ここでの解決策は、分散計算カーネルが分離可能であることを認識することです。つまり、水平パスを実行し、中間結果を格納し、垂直パスで終了できます。これにより、2
つのパスでピクセルごとのタップの数が 34 に減少します。

クロス
レーン操作を利用して、隣接するレーンのレジスタにある値を共有できます。さらに、光線ヒットに圧縮ビットマスクを使用すると、289
タップを 18 個のスカラー読み込みまで下げることもできます。

垂直パスは、追加の中間ターゲットとの間で書き込みと読み取りを行う必要があるメモリ帯域幅の要件を回避するために、テンポラル再投影パス自体に統合されます。

**Disocclusion Mask**
は、画面上の新しい領域を決定します。これらは、以前は画面領域の外部にあったが、カメラの動きにより表示されるようになった領域、または現在は
Occluder の移動が原因で表示される領域です。

この情報は通常、分離と呼ばれ、このパスでは、どのピクセルが除外され、どのピクセルが除外されなかったかをフラグ付けするバイナリ
マスクを記述します。

新しい領域を特定するために、前のフレームに存在するはずの深度値をピクセルごとに計算し、最後のフレームの深度バッファーを使用して実際の値と比較します。深度値が一致しない場合、これは割り当て解除です。

前の深度値を計算するには、現在のフレーム内のクリップ空間の位置を取得し、前のフレーム内のクリップ空間の位置を返す再投影行列を使用します。この位置から目的の深度値を取得できます。

reprojection_matrix = view_projection_inverse_matrix \*
previous_view_projection_matrix;

![](./media/image10.png)

> 割り当て解除マスクは、画面上の新しいピクセルにフラグを設定します

上の図では、1%
を超える深度誤差で割り込みをトリガーするのに十分です。これは一般的なケースでは適切に機能しますが、通常は縮小角度で発生する大きな深度バリエーションを示す画面領域では分解されます。

これを修正するには、サーフェイスの傾斜角度に基づいてピクセルあたりのしきい値を動的に変更します
(カメラの前方方向のドット積と表面法線ベクトルを使用して推定されます)。

| ![](./m                           | ![](./m                           | | edia/image11.png){width="3.125in" | edia/image12.png)                   |
| > 一定の深さのしきい値 |  > アダプティブ深度のしきい値      |
|-----------------------------------|-----------------------------------|
|

アダプティブ
バージョンでは削除される、大きな深度のバリエーションによってフロア上の水平線が無効であることに注意してください。

**再投影** では、速度ベースの再投影を実行するために提供される Local
Neighborhood データ、Disocclusion
データ、およびテンポラル履歴バッファーが使用されます。

一時的な分散を計算します。これは、画像内のノイズの量の推定値です。この値は、ノイズ除去に必要なぼかしの量を促進するために、空間パスによって使用されます。

![](./media/image13.png)

> 一時的な分散

マスクされた分散領域によってピクセルごとのサンプル数がリセットされるため、一時的なサンプルが使用できる時間的なサンプルが少ない場合、テンポラル分散は、このパスの
Local Neighborhood セクションで説明されている空間と組み合わされます。

if (moments_current.z \< 16.0f)

{

const float variance_boost = max(16.0f -- moments_current.z, 1.0f);

variance = max(variance, spatial_variance);

variance \*= variance_boost; // boost variance on first frames

}

一時的な再投影が機能しない領域のノイズを取り除くために、少数のサンプルが使用可能な場合に分散の値をブーストします。

| ![](.                             | ![](.                             | | /media/image14.png){width="3.0in" | /media/image15.png)                   |
| > 分散ブーストなし |  > 分散ブーストあり                |
|-----------------------------------|-----------------------------------|
|

分散ブーストを適用せずに、画像の下部と左端の部分が非常に小さいことに注目してください。分散値を大きくすると、テンポラル履歴がほとんどまたはまったくないピクセルに対して、より積極的な空間ぼかしが発生します。これは、履歴が長くなるにつれてクールオフされ、無効になります。

瞬間と分散が計算されると、シェーダーは前のフレームのシャドウ値を履歴バッファーから再投影し、サンプルを再使用してノイズ除去します。

ここでの重要な問題の 1
つは、影が移動する可能性があり、このモーションがベロシティ
マップに反映されない点です。そのため、これらのケースの履歴サンプルを受け入れるか拒否する方法が必要です。これを行うには、再投影された履歴値を、前に計算したローカルの領域にクランプします。

| ![](./media/image16               | ![](./media/image17               | | .png){width="2.228571741032371in" | .png)                   |
| > Naïve ブレンド |  > 近隣クランプ                    |
|-----------------------------------|-----------------------------------|
|

多くのテンポラル
サンプルが誤ってブレンドされると、シャドウが大幅に消えることがわかります。一方、近隣クランプは、応答性の高いフィルターを取得するのに役立ち、動いている影の詳細を保持します。

// Compute the clamping bounding box

const float std_deviation = sqrt(local_variance);

const float nmax = local_mean + 0.5f \* std_deviation;

const float nmin = local_mean - 0.5f \* std_deviation;

// Clamp reprojected sample to local neighborhood

const float shadow_previous = SampleHistory(uv - velocity);

const float shadow_clamped = clamp(shadow_previous, nmin, nmax);

近隣クランプの実装は上記のコードに似ていますが、
FFX_DNSR_Shadows_TileClassification 関数の末尾に向かって確認できます。

クランプされた履歴情報は、単純な指数移動平均ブレンドを使用して、最終的に現在のフレームとマージされます。

ただし、次の場所でブレンド係数を選択する必要があります。

-   ブレンド係数が低いと、ほとんどの場合、現在のフレーム値が保持され、応答性は高くなりますが、フィルターは不安定になります。

-   ブレンド係数が高い場合、ほとんどの場合、クランプされた履歴値が保持され、安定したものの応答しないフィルターが生成されます。

1
つの解決策は、使用可能な履歴の量に基づいてピクセルあたりのブレンド係数を選択することです。履歴がほとんどない場合は、低いブレンド係数を求めますが、再投影について確信している場合は、高いブレンド係数を求めます。

| ![](.                             | ![](.                             | | /media/image18.png){width="3.2in" | /media/image19.png)                   |
| > 定数ブレンド係数 |  > アダプティブ ブレンド係数       |
|-----------------------------------|-----------------------------------|
|

アダプティブ
バージョンでは、より応答性の高いフィルターが生成され、初期レンダリングから一時的な発生の大部分が排除される点に注目してください。

**ffx_denoiser_shadows_filter**

FidelityFX RT Shadow デノイザー
の最後のパスは、空間フィルター処理を実行をするもので、3
回実行されます。3
つのパスのサンプリング元のリージョンは比較的小さいため、グループ共有メモリを使用してサンプルをキャッシュする最適化されたカーネルが実行されます。

Edge-Avoiding À-T pull Wavelet (EAW)
フィルタリング手法を実装します。ここでは、ぼかしが繰り返し実行され、複数のパスで半径値が増加します。

| ![](./media/image2   | ![](./media/image     | ![](./media/image     | | 0.png){width="2.0in" | 21.png){width="2.0in" | 22.png)       |
| > EAW パスなし |  > 単一 EAW パス |  > 3 回の EAW パス     |
|----------------------|-----------------------|-----------------------|
|  |

さらに、テンポラル
パスで推定される分散は、後続の各ぼかしパスの後にフィルター処理された値で更新されます。これにより、不要なぼかしの量をクールオフできます。

| ![](./media/image     | ![](./media/image     | ![](./media/image2   | | 23.png){width="2.0in" | 24.png){width="2.0in" | 5.png)      |
| > 1 > 回 のぼかしパス後の分散 |  > 2 > 回 のぼかしパス後の分散 |  > 3 > 回 のぼかしパス後の分散 |
|-----------------------|-----------------------|----------------------|
|  |

以降のぼかしパスごとに分散がどのように減少するかに注目してください。

## 統合

ffx_rtshadowdenoiser パッケージには、次の 4 つの hlsl
シェーダーが含まれています。

-   ffx_denoiser_shadows_filter.h

-   ffx_denoiser_shadows_prepare.h

-   ffx_denoiser_shadows_tileclassification.h

-   ffx_denoiser_shadows_util.h

必要なすべてのデータは、アプリケーションによって作成される
Get/Read/Write スタイル API 関数を介して提供されます。

このサンプルでは、統合は次の方法で提供されます。

-   prepare_shadow_mask_d3d12.hlsl

-   tile_classification_d3d12.hlsl

-   filter_soft_shadows_pass_0\_d3d12.hlsl

-   filter_soft_shadows_pass_1\_d3d12.hlsl

-   filter_soft_shadows_pass_2\_d3d12.hlsl

Scarlett の Wave32 モードではフィルター
パスの方が適切に機能することがわかりました。このサンプルでは、これらのパスの既定値です。Wave64
モードでは、タイル分類パスの方が高速です。

シェーダーは明示的な FP16 を使用し、DXC に -enable-16bit-types
を渡す必要があります。

**データフロー**

このサンプルは、可能な限り簡単に従う方法でコード
データフローをレイアウトすることを目的としており、リソースの最も効率的な使用ではない可能性があります。さまざまなパスのリソース使用のマップを次に示します。

![](./media/image26.png)

## 

**TAA**

一時的なアンチエイリアシングまたは TAA
は、一時的な再投影を実行することによって、レンダリングされたイメージのアンチエイリアシングを目的としています。TAA
は、デノイザーの実行後にイメージをさらに 安定させ
、クリーンアップできます。

| ![](./media/image27               | ![](./media/image2                | | .png){width="3.125436351706037in" | 8.png)     |
| > TAA 使用なし |  > TAA 使用あり                    |
|-----------------------------------|-----------------------------------|
|

TAA
を使用しないレンダリングでは、空間ぼかしが一致するサンプルを見つけられないエッジにアーティファクトがどのように表示されるかに注目してください。

このサンプルでは最終的な TAA パスは実装されませんが、タイトルで TAA
が使用されている場合は、シーンで意味をなすように、デノライザー出力を含めて実験する必要があります。

注意:UI
に表示されるワークロードのタイミングは、電源プロファイルのためにデスクトップ構成によって異なる場合があります。最も正確なタイミングを得るには、PIX
のプロファイルを使用します。

# 更新履歴

このサンプルは 2021 年 1 月に作成されました。

# プライバシーに関する声明

サンプルをコンパイルして実行する場合、サンプルの使用状況を追跡するために、サンプル実行ファイルのファイル名が
Microsoft に送信されます。このデータ
コレクションからオプトアウトするには、Main.cpp の「Sample Usage
Telemetry」というラベルの付いたコードのブロックを削除します。

全般的な Microsoft のプライバシー ポリシーの詳細については、「[Microsoft
プライバシー
ステートメント](https://privacy.microsoft.com/en-us/privacystatement/)」を参照してください。

# 免責事項

本ドキュメントで提供される情報は、情報提供のみを目的としており、予告なく変更される可能性があります。このドキュメントを準備するに当たってすべての予防措置を講じましたが、技術的な不正確さ、欠落、文字体裁上の誤りが含まれている可能性があり、AMD
は、この情報を更新または修正する義務を負いません。Advanced Micro
Devices, Inc.
は、本ドキュメントの内容の正確性または完全性に関して一切の表明または保証を行いません。また、AMD
ハードウェア、ソフトウェア、または本ドキュメントに記載されているその他の製品の運用または使用に関して、特定の目的に対する非侵害、商品性、適合性に関する暗黙の保証を含め、いかなる種類の責任も負いません。本ドキュメントにより、いかなる知的財産権に対しても、黙示的または禁反言によるライセンスは付与されません。AMD
の製品の購入または使用に適用される使用条件と制限は、当事者間の署名済み契約または
AMD の標準販売条件に記載されています。

AMD、AMD Arrow ロゴ、Radeon、RDNA、Ryzen、およびその組み合わせは
Advanced Micro Devices, Inc.
の商標です。この文書で使用されているその他の製品名は、識別のみを目的としており、それぞれの会社の商標である可能性があります。

Windows は、米国およびその他の国における Microsoft Corporation
の登録商標です。

Xbox は、米国およびその他の国における Microsoft Corporation
の登録商標です。

© 2021 Advanced Micro Devices, Inc.All rights reserved.
