![](./media/image1.png)

# 고급 ESRAM 샘플

*이 샘플은 Microsoft 게임 개발 키트(2022년 3월)와 호환됩니다.*

# 설명

이 샘플은 D3D 리소스의 효율적인 별칭 메모리에 대한 고급 DirectX 12.x 메모리 기능 사용을 보여줍니다. 이 샘플의 핵심에 있는 API는 ID3D12CommandQueue::CopyPageMappingsX 및 ID3D12CommandQueue::CopyPageMappingsBatchX입니다. 이들 함수를 통해 CPU 페이지 테이블 항목을 GPU 타임라인의 GPU TLB에 복사할 수 있으므로 가상 D3D 리소스를 즉시 메모리 페이지에 매핑할 수 있습니다.

이 샘플은 이 기능을 활용하여 64KB 페이지 세분성으로 개별 ESRAM & DRAM 블록을 매핑하는 일시적인 리소스 할당자를 구현합니다. 이러한 구현을 통해 ESRAM의 전체 기능을 활용하는 데 사용되는 프레임의 GPU 메모리 사용량이 최적으로 압축됩니다. 인터페이스는 XG 메모리 라이브러리에서 XGMemoryLayout 페이지 매핑 함수의 뾰족한 측면을 미러링합니다.

이 샘플은 단순히 모든 ESRAM 옵션과 시각화가 비활성화된 상태로 장면을 렌더링합니다. ![](./media/image2.jpeg)
| | |
|---|---|
|참고: Xbox One X & Xbox Series X|S에는 ESRAM이 없습니다. 해당 플랫폼에서|


# 샘플 빌드

Xbox One 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.XboxOne.x64`(으)로 설정합니다.

Xbox Series X|S 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.Scarlett.x64`(으)로 설정합니다.

*자세한 내용은* *GDK 설명서의* __샘플 실행을 참조하세요.__

# 샘플 사용

샘플의 기본 기능을 사용하면 일시적인 텍스처 리소스가 할당되는 위치를 조작할 수 있습니다. 프레임에 사용되는 리소스는 장면 색, 장면 깊이, 윤곽선용 2개, 블룸용 2개를 위한 텍스처입니다. 리소스의 ESRAM 컴퍼지션은 맨 왼쪽에 리소스 메모리의 백분율로 표시됩니다. ESRAM 레이아웃의 시각화는 각 텍스처의 ESRAM & DRAM 컴퍼지션의 변경 내용에 대한 즉각적인 피드백을 제공합니다. 각 리소스의 ESRAM 공간은 Y축으로 표시되고 수명은 X축으로 표시됩니다. 임시 축으로 표시되는 GPU 타이밍은 단추를 눌러 새로 고칠 수 있습니다.

## 컨트롤

| 동작 | Gamepad |
|---|---|
| 원점에서 카메라를 쪽으로/멀리 이동 | 왼쪽 엄지스틱 위/아래 |
| 궤도 카메라 | 오른쪽 엄지스틱 |
| 카메라 다시 설정 | 오른쪽 엄지스틱(클릭) |
| 일시적인 텍스처 주기 | D-패드 왼쪽/오른쪽 |
| ESRAM 백분율 변경 | 방향 패드 위/아래 |
| 강조 표시된 개체 주기 | 왼쪽/오른쪽 범퍼 |
| 타임라인 새로 고침 | A 버튼 |
| 끝내기 | 보기 버튼 |

# 구현 참고 사항

ESRAM과 DRAM에서 할당된 64KB 메모리 페이지(페이지 풀)의 블록을 매핑하기 위해 큰 가상 주소 공간이 만들어집니다. 페이지 풀은 ID3D12Device::RegisterPagePoolX를 통해 DirectX12에 등록되며, 더 이상 사용하지 않을 때는 ID3D12Device::UnregisterPagePoolX를 통해 등록 취소됩니다. 이 매핑은 GPU 페이지 테이블에 직접 복사하기 위한 CPU 페이지 테이블 항목을 준비하는 데 사용됩니다.

ID3D12CommandQueue::CopyPageMappingsX 또는 ID3D12CommandQueue::CopyPageMappingsBatchX 함수를 사용하면 이러한 페이지 풀 내의 페이지 범위를 GPU 타임라인의 지정된 GPU 가상 주소에 매핑할 수 있습니다. 이렇게 하면 가상 D3D 리소스를 64KB 실제 페이지에 즉각적으로 유연하게 매핑할 수 있습니다. 이 기능을 사용하면 리소스 간 메모리 별칭을 간단하게 만들고 전체 힙을 재미있게 만들 수 있습니다.

![](./media/image3.png)

그림 1: 샘플에서 사용되는 메모리 매핑 패러다임. ESRAM(사용 가능한 경우)은 가상 주소 공간의 첫 32MB에 매핑되고 필요에 따라 4MB DRAM 페이지 풀이 추가됩니다.

페이지 블록의 생성 및 관리는 PageAllocator 클래스에 의해 수행됩니다. 가상 주소 범위가 제공되며 할당자는 필요에 따라 페이지 풀을 이 범위에 순차적으로 매핑합니다. 그러면 페이지 풀이 'RegisterPagePoolX'를 사용하여 DirectX12에 등록됩니다. 할당자 페이지의 사용량은 완전히 추적되어, 페이지를 처음부터 끝까지 할당하고 다시 릴리스될 때 페이지를 바꿉니다.

TransientCache는 가상 D3D 리소스 관리를 담당합니다. 요청 시 생성되지만 일반적인 리소스를 다시 만드는 불필요한 오버헤드를 방지하기 위해 캐시됩니다. 이러한 리소스를 캐싱하는 메모리 오버헤드는 가상 주소 공간만 할당하기 때문에 사실상 0입니다. 각 리소스는 프레임당 한 번만 할당할 수 있습니다.

이 TransientAllocator 클래스는 페이지 할당자 및 임시 캐시를 사용하여 사용자에 대한 리소스 요청을 이행합니다. 리소스가 요청되면 TransientCache에서 인스턴스를 가져옵니다. 그런 다음 PageAllocators에서 필요한 수의 페이지를 할당하고 토큰을 구문 분석하여 페이지 수준 세분성에서 ESRAM 또는 DRAM 사용 여부를 결정합니다. 그런 다음 나중에 'CopyPageMappingsBatchX', 즉 D3D12XBOX_PAGE_MAPPING_BATCH 및 D3D12XBOX_PAGE_MAPPING_RANGE 구조의 벡터에 제공되도록 적절한 구조가 생성됩니다.

![샘플 스크린샷](./media/image4.png)

그림 2: 메모리 요구 사항을 충족하기 위해 페이지 풀 내의 페이지 범위에 매핑되는 가상 리소스. 이러한 매핑은 CopyPageMappingsX와 CopyPageMappingsBatchX 호출의 결과입니다. 이 시각화에서는 시각적 편의를 위해 두 개의 리소스만 사용했으며, 메모리에 별칭을 지정하지 않았습니다. 하지만 메모리 별칭은 이 기술에서 기대할 수 있는 이점입니다.

메모리 별칭 지정으로 인해 TransientAllocator는 필요한 경우 셰이더와 캐시 플러시를 수행하는 책임도 맡습니다. DirectX12 플러시에서는 리소스 장벽의 일부로 삽입됩니다. 여기서는 이 시스템을 우회했으므로 메모리 별칭을 지정하려면 자체 플러시를 수동으로 삽입해야 합니다. TransientAllocator는 리소스의 연결된 뷰를 검사하여 플러시해야 하는 셰이더 단계와 캐시를 결정합니다.

마지막으로, 할당된 임시 리소스를 사용하는 명령 목록이 명령 큐에 제출되기 전에 리소스 매핑을 완료하려면 TransientAllocator에서 'Finalize'를 호출해야 합니다. 이 시점에서 CopyPageMappingsBatchX 호출을 명령 큐에 배치하여 후속 명령 목록에서 사용할 리소스의 메모리 매핑을 설정합니다.

# 업데이트 기록

2018년 8월 6일 -- 샘플 만들기.

2019년 12월 17일 -- Microsoft GDK로 이식.

# 개인정보처리방침

샘플을 컴파일하고 실행하는 경우 샘플 사용량을 추적할 수 있도록 샘플 실행 파일의 파일 이름이 Microsoft에 전송됩니다. 이 데이터 수집을 옵트아웃하려면 Main.cpp에서 "샘플 사용량 원격 분석"이라는 레이블이 지정된 코드 블록을 제거할 수 있습니다.

일반적인 Microsoft의 개인 정보 정책에 대한 자세한 내용은 [Microsoft 개인정보처리방침](https://privacy.microsoft.com/en-us/privacystatement/)을 참조하세요.


