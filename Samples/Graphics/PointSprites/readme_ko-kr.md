![](./media/image1.png)

# 포인트 스프라이트

*이 샘플은 Microsoft 게임 개발 키트(2022년 3월)와 호환됩니다.*

# 설명

DirectX 12에서 포인트 스프라이트를 렌더링하는 10가지 방법을 보여 줍니다. 각 메서드가 프로파일링되고 렌더링 매개 변수가 지정된 경우 각 메서드의 성능 문자를 표시하기 위해 헤드업 비교가 표시됩니다.

Xbox One 샘플에서는 기하 도형 셰이더에 대한 온/오프 칩 메모리를 지정하는 방법도 자세히 설명합니다. Xbox 시리즈에서는 이러한 차이점을 사용할 수 없습니다.
| | |
|---|---|
|X|S.|

![](./media/image3.png)

# 샘플 빌드

Xbox One 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.XboxOne.x64`(으)로 설정합니다.

Xbox Series X|S 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.Scarlett.x64`(으)로 설정합니다.

*GDK 설명서의* __샘플 실행__에서 *자세한 내용을 알아보세요.*

# 샘플 사용

이 샘플에서는 다음 컨트롤을 사용합니다.

| 동작 | Gamepad |
|---|---|
| 샘플을 종료합니다. | 보기 버튼 |
| 스프라이트 크기 늘리기 | A 버튼 |
| 스프라이트 크기 줄이기 | B 버튼 |
| Null 뷰포트 설정/해제 | Y 버튼 |
| 선택한 테스트 변경 | 방향 패드 위/아래 |
| 강조 표시된 테스트 토글 | X 버튼 |

# 구현 참고 사항

그래픽 파이프라인이 발전함에 따라 기하 도형 셰이더와 같이 완전히 유연하고 사용자 지정 가능한 단계를 사용하기 위해 포인트 스프라이트에 대한 최상위 지원이 제거되었습니다. 실제로 지점 스프라이트는 GPU의 모든 기하 도형 관련 단계(꼭짓점, 기하 도형, 공간 분할 및 메시 셰이더)에서 구현할 수 있습니다. 메서드의 이상적인 선택은 대/소문자를 기준으로 성능을 측정해야 하지만 점 스프라이트를 확장하기 위해 기하 도형 셰이더를 사용하는 것이 간단한 점 스프라이트를 렌더링하는 가장 효율적인 방법이 아닌 것 같습니다.

## 삼각형 및 쿼드

렌더링 파이프라인의 병목 현상이 발생한 위치에 따라 삼각형 또는 쿼드의 성능이 다를 수 있습니다. 채우기 속도 바운드 상황에서 쿼드는 투명 픽셀에서 픽셀 셰이더를 실행할 필요가 없으므로 삼각형 위에 성능 가장자리가 있습니다. 렌더링이 기하 도형 단계에서 바인딩되는 경우 쿼드 대신 삼각형을 출력하는 것이 좋습니다. 여러 복잡한 렌더링 상황에서 삼각형은 쿼드보다 빠를 수 있습니다.

이 샘플에서는 각 메서드가 삼각형과 쿼드를 대조하여 점 스프라이트의 서로 다른 크기로 차이를 표시하는 방법을 보여 줍니다.

## 메서드 1 - 꼭짓점 + 기하 도형 셰이더

파이프라인이 초기화되어 꼭짓점 셰이더가 꼭짓점을 정상적으로 읽은 다음 기하 도형 셰이더는 입력 꼭짓점당 쿼드 또는 삼각형을 출력합니다. 또한 이러한 테스트는 온칩과 오프칩 기하 도형 셰이더 할당을 비교합니다. 컴파일러는 기본적으로 꼭짓점과 기하 도형 단계 간에 단계 간 데이터를 저장하는 데 사용되는 오프칩 메모리를 사용합니다.

*장점*

- 잘 알려져 있고 간단합니다.

*단점*

- 대부분의 설정이 필요합니다.

- 모든 경우에 가장 빠른 것은 아닙니다.

## 메서드 2 -- 기하 도형 셰이더만

이 메서드는 빈 꼭짓점 셰이더를 사용합니다. 꼭짓점 데이터를 로드하기 위해 기하 도형 셰이더는 SV_PrimitiveID 인덱스를 사용하여 꼭짓점 버퍼의 원시 바이트 뷰에서 버퍼 로드를 수행합니다(점 목록의 경우 기하 도형 셰이더의 SV_PrimitiveID 꼭짓점 셰이더의 SV_VertexID 동일함). 꼭짓점이 로드된 후 점 스프라이트 확장은 메서드 1에서와 같이 수행됩니다. 온칩과 오프칩 GS 성능은 마찬가지로 여기에서 테스트됩니다.

*장점*

- VS는 no-op이므로 입력 레이아웃이 필요하지 않습니다.

- VS와 GS 간에 내부 트래픽이 발생하지 않으므로 메서드 1보다 빠르게 수행됩니다.

*단점*

- 수동 꼭짓점 로드에는 각 꼭짓점 레이아웃에 대해 서로 다른 셰이더 변형이 필요합니다. 고도로 최적화된 코드의 경우 이는 문제가 되지 않습니다.

- 이 메서드는 이해하기가 약간 더 어렵습니다.

## 메서드 3 -- 꼭짓점 셰이더만

DX11에서는 기하 도형 셰이더를 사용하여 점을 쿼드 또는 삼각형으로 확장할 필요가 없으며 꼭짓점 셰이더를 대신 사용할 수 있습니다. DX11에서 꼭짓점 셰이더 단계는 원시 바이트 UAV를 읽을 수 있으므로 꼭짓점 버퍼의 SV_VertexID 및 원시 바이트 뷰가 있으면 꼭짓점을 수동으로 읽을 수 있습니다.

따라서 꼭짓점을 삼각형 또는 쿼드로 확장하려면 그리기 호출에서 꼭짓점을 3배 이상 또는 6배 더 렌더링하고, 셰이더에서 3 또는 6으로 나누기를 수행하여 꼭짓점의 인덱스를 가져오고, 이 인덱스를 사용하여 꼭짓점을 로드하고, 나누기의 나머지 부분에 따라 확장하여 스프라이트의 모퉁이를 가져와야 합니다.

*장점*

- 이 메서드는 간단하고 빠르며 모든 수준의 그래픽 프로그래머가 쉽게 이해할 수 있습니다.

- SV_VERTEXID 시스템 생성 값만 사용하므로 VS에는 입력 레이아웃이 필요하지 않습니다.

*단점*

- 꼭짓점 로드는 수동이므로 다른 꼭짓점 레이아웃을 로드하는 데 다른 셰이더가 필요할 수 있습니다. 가장 빠른 절대 메서드를 원하는 경우에는 문제가 되지 않습니다.

## 메서드 4 -- 꼭짓점 셰이더 인스턴스화

인스턴스를 사용하여 GPU를 사용하여 지점 스프라이트 꼭짓점을 로드하고 SV_VertexID 확장을 위한 스프라이트의 모퉁이를 결정할 수 있습니다. 이 메서드는 이전 메서드보다 약간 느리지만 다른 메서드보다 일관되게 더 빠릅니다.

*장점*

- 두 번째로 빠른 메서드로, 메서드 3과 매우 유사한 성능입니다.

- 셰이더에 더 적은 ALU가 있도록 나누기가 필요하지 않습니다.

- 꼭짓점 로드는 입력 레이아웃을 사용하여 수행되므로 셰이더를 수정하지 않고도 다른 꼭짓점 레이아웃을 로드할 수 있습니다.

- 매우 큰 크기의 포인트 스프라이트에서 성공하는 방법인 것 같습니다.

*단점*

- 없음

## 메서드 5 -- 테셀레이션 단계

테셀레이션 단계를 사용하여 단일 입력 꼭짓점에서 삼각형과 쿼드를 생성할 수 있습니다. 이 메서드의 성능은 기하 도형 셰이더 기반 메서드와 동등하지만 스프라이트 셰이프가 더 많을수록 더 유연합니다. 예를 들어 쿼드 도메인에서 테셀레이션하면 쿼드 대신 원을 출력할 수 있습니다. 픽셀 셰이더가 매우 느리고 스프라이트가 원인 경우 보다 효율적일 수 있습니다.

*장점*

- 거의 임의의 기하 도형을 출력할 수 있습니다.

*단점*

- 기하 도형 셰이더 접근 방식과 동일합니다.

## 메서드 6 -- 메시 셰이더 파이프라인

메시 셰이더는 절차적 기하 도형을 렌더링하기 위한 매우 자연스러운 프로그래밍 모델을 제공합니다. 이 메서드는 메시 셰이더 파이프라인에서 입력 어셈블러를 생략하면 엄청난 이점을 볼 수 있습니다. 파이프라인의 컬링 후 부분에서 워크로드가 병목 상태가 되면 성능상의 이점이 줄어듭니다.

메시 셰이더를 사용할 때 삼각형과 쿼드의 옵션은 없습니다. 출력 기하 도형은 선 또는 삼각형의 인덱싱된 꼭짓점 목록입니다.

*장점*

- 빠른 번개! 또한 메시 셰이더 내에서 파티클을 선별하는 기능도 제공합니다(구현되지 않음).

*단점*

- 메시 셰이더는 구조적으로 약간 더 복잡하며 컴퓨팅 및 기존 그래픽 워크로드를 모두 이해해야 합니다. 입력 어셈블러가 부족하기 때문에 CPU 디스패치 쪽에서 약간의 계산과 셰이더 코드의 수동 입력 인출이 필요합니다.

## 결론:

위의 모든 메서드는 다른 GPU 부하를 고려하여 다르게 수행되므로 경우에 가장 적합한 메서드를 선택합니다.

# 업데이트 기록

2019년 4월 12일 -- Xbox 샘플 프레임워크에서 DX12로 포트.

| | |
|---|---|
| 2020년 2월 20일 -- Xbox Series X용 업데이트 | S |

2020년 6월 8일 -- 메시 셰이더 파티클이 추가되었습니다.

# 개인정보처리방침

샘플을 컴파일하고 실행하는 경우 샘플 사용량을 추적할 수 있도록 샘플 실행 파일의 파일 이름이 Microsoft에 전송됩니다. 이 데이터 수집을 옵트아웃하려면 Main.cpp에서 "샘플 사용량 원격 분석"이라는 레이블이 지정된 코드 블록을 제거할 수 있습니다.

일반적인 Microsoft의 개인 정보 정책에 대한 자세한 내용은 [Microsoft 개인정보처리방침](https://privacy.microsoft.com/en-us/privacystatement/)을 참조하세요.


