![](./media/image1.png)

# ポイント スプライト

*このサンプルは、Microsoft Game Development Kit と互換性があります (2022 年 3 月)*

# 説明

DirectX 12 でポイント スプライトをレンダリングする 10 通りの方法を示します。 各メソッドがプロファイリングされ、レンダリング パラメーターを指定して各メソッドのパフォーマンス文字を表示するヘッドアップ比較が表示されます。

Xbox では、このサンプルはジオメトリ シェーダーのオン/オフチップ メモリを指定する方法についても詳しく説明します。 この違いは Xbox Series では使用できません
| | |
|---|---|
|X|S.|

![](./media/image3.png)

# サンプルのビルド

Xbox One 開発キットを使用している場合は、アクティブなソリューション プラットフォームを `Gaming.Xbox.XboxOne.x64` に設定します。

Xbox Series X|S 開発キットを使用している場合は、アクティブ ソリューション プラットフォームを `Gaming.Xbox.Scarlett.x64` に設定します。

*詳細については、* *GDK ドキュメント*の「__サンプルの実行__」を参照してください。

# サンプルの使用方法

このサンプルでは、次のコントロールを使用します。

| 操作 | ゲームパッド |
|---|---|
| サンプルを終了する。 | ビュー ボタン |
| スプライト サイズを大きくする | A ボタン |
| スプライト サイズを小さくする | B ボタン |
| Null ビューポートの切り替え | Y ボタン |
| 選択されたテストの変更 | 方向パッド (上/下) |
| 強調表示されたテストの切り替え | X ボタン |

# 実装メモ

グラフィックス パイプラインの進化に伴い、ジオメトリ シェーダーのような完全に柔軟でカスタマイズ可能なステージの使用を優先して、ポイント スプライトのファースト クラスのサポートが削除されました。 実際、頂点、ジオメトリ、テッセレーション、メッシュ シェーダーなど、GPU のすべてのジオメトリ関連ステージでポイント スプライトを実装できます。 メソッドの理想的な選択は、ケースバイケースでパフォーマンスを測定することに基づいている必要がありますが、ポイント スプライトを展開するためにジオメトリ シェーダーを使用することは、単純なポイント スプライトをレンダリングする最も効率的な方法ではないようです。

## 三角形と四角形

レンダリング パイプラインがボトルネックになっている場所に応じて、三角形または四角形のパフォーマンスが異なる場合があります。 フィル レートのバインドされた状況では、四角形は透明ピクセルでピクセル シェーダーを実行する必要がないため、三角形に対してパフォーマンス エッジを持ちます。 レンダリングがジオメトリ ステージでバインドされている場合は、四角形ではなく三角形を出力するのが理にかなっています。 多くの複雑なレンダリング状況では、三角形は四角形よりも高速になる場合があります。

このサンプルでは、ポイント スプライトのさまざまなサイズの違いを示すために、三角形と四角形をコントラストする各メソッドを示します。

## 方法 1 - 頂点 + ジオメトリ シェーダー

パイプラインは、頂点シェーダーが頂点を正常に読み取り、ジオメトリ シェーダーが入力頂点ごとに四角形または三角形を出力するよう初期化されます。 これらのテストでは、オンチップ シェーダー割り当てとオフチップ ジオメトリシェーダー割り当ても比較されます。 コンパイラでは、頂点ステージとジオメトリ ステージ間のステージ間データを格納するために使用されるオフチップ メモリが既定で使用されます。

*利点*

- よく知られており、シンプルです。

*デメリット*

- ほとんどの設定が必要です。

- すべてのケースで、最も高速であるわけではありません。

## メソッド 2 -- ジオメトリ シェーダーのみ

このメソッドは、空の頂点シェーダーを使用します。 頂点データを読み込むために、ジオメトリ シェーダーは SV_PrimitiveID インデックスを使用して頂点バッファーの生バイト ビューでバッファー読み込みを実行します (ポイント リストの場合、ジオメトリ シェーダーの SV_PrimitiveID は頂点シェーダーの SV_VertexID と同じです)。 頂点が読み込まれると、方法 1 と同様にポイント スプライトの展開が実行されます。 オンチップとオフチップの GS パフォーマンスは、ここでも同様にテストされています。

*利点*

- VS は no-op であるため、入力レイアウトは必要ありません。

- VS と GS の間で内部トラフィックが発生しないため、メソッド 1 よりも高速に実行されます。

*デメリット*

- 手動の頂点読み込みでは、頂点レイアウトごとに異なるシェーダー バリアントが必要です。 高度に最適化されたコードの場合、これは問題ではありません。

- このメソッドはもう少し難解です。

## メソッド 3 -- 頂点シェーダーのみ

ジオメトリ シェーダーを使用してポイントを四角形または三角形に拡張するだけの場合、DX11 では実際には必要ありません。頂点シェーダーを使用して代わりにこれを行うことができます。 DX11 では、頂点シェーダー ステージは未加工のバイト UAV を読み取ることができるため、頂点バッファーの SV_VertexID と未加工のバイト ビューを使用すると、頂点を手動で読み取ることができます。

そのため、頂点を三角形または四角形に展開するには、描画呼び出しで 3 倍または 6 倍の頂点をレンダリングし、シェーダーで 3 または 6 で除算を実行して頂点のインデックスを取得し、このインデックスを使用して頂点を読み込み、除算の残りの部分に基づいて頂点を展開してスプライトの角を取得する必要があります。

*利点*

- この方法は、シンプルで高速で、あらゆるレベルのグラフィックス プログラマーが理解しやすい方法です。

- VS では、システムで生成された値 SV_VertexID のみを使用するため、入力レイアウトは必要ありません。

*デメリット*

- 頂点の読み込みは手動であるため、別の頂点レイアウトを読み込むには別のシェーダーが必要になる場合があります。 これは、最も高速な方法が必要な場合は問題ではありません。

## メソッド 4 -- 頂点シェーダーのインスタンス化

インスタンス化を使って GPU にスプライトの頂点を読み込み、SV_VertexID を使ってスプライトの角を決定して拡大することができます。 このメソッドは、前のメソッドよりも若干遅くなりますが、他のどのメソッドよりも一貫して高速です。

*利点*

- 2 番目に高速なメソッドで、メソッド 3 と非常によく似たパフォーマンスです。

- シェーダーの ARU が少なくなるため、除算は必要ありません。

- 頂点の読み込みは入力レイアウトを使用して実行されるため、シェーダーを変更せずにさまざまな頂点レイアウトを読み込むことができます。

- 非常に大きなサイズのポイント スプライトに対する優れた方法のようです。

*デメリット*

- なし

## メソッド 5 -- テッセレーション ステージ

テッセレーション ステージを使用して、1 つの入力頂点から三角形と四角形を生成できます。 このメソッドのパフォーマンスは、ジオメトリ シェーダー ベースのメソッドと同等ですが、より多くのスプライトシェイプが可能であるため、柔軟性が向上します。 たとえば、四角形 ドメインにテッセレーションすることで、四角形ではなく円を出力できます。ピクセル シェーダーが非常に遅く、スプライトが円の場合、これはより効率的な場合があります。

*利点*

- ほぼ任意のジオメトリ図形を出力できます。

*デメリット*

- ジオメトリ シェーダーのアプローチと同じです。

## メソッド 6 -- メッシュ シェーダー パイプライン

メッシュ シェーダーは、手続き型ジオメトリをレンダリングするための非常に自然なプログラミング モデルを提供します。 この方法では、メッシュ シェーダー パイプラインで入力アセンブラーが省略された場合の大きな利点を確認できます。 パイプラインのカリング後の部分でワークロードがボトルネックになるにつれて、パフォーマンスの利点が低下します。

メッシュ シェーダーを使用する場合、三角形と四角形のオプションはありません。出力ジオメトリは、線または三角形のインデックス付き頂点のリストです。

*利点*

- 超高速です。 また、メッシュ シェーダー内のパーティクルをカリングする機能も提供します (実装されていません)。

*デメリット*

- メッシュ シェーダーは構造的にもう少し複雑であり、コンピューティングワークロードと従来のグラフィックス ワークロードの両方を理解する必要があります。 入力アセンブラーがない場合は、CPU ディスパッチ側での計算と、シェーダー コードでの手動入力フェッチが必要です。

## まとめ:

上記のすべての方法は、異なる GPU 負荷を指定して異なる方法で実行されるため、お客様の場合に最適な方法を選択してください。

# 更新履歴

2019 年 4 月 12 日 -- Xbox Sample Framework から DX12 への移植。

| | |
|---|---|
| 2020 年 2 月 20 日 -- Xbox Series X の更新プログラム | S |

2020 年 6 月 8 日 -- メッシュ シェーダー パーティクルを追加しました。

# プライバシーに関する声明

サンプルをコンパイルして実行する場合、サンプルの使用状況を追跡するために、サンプルの実行可能ファイルのファイル名が Microsoft に送信されます。 このデータ コレクションからオプトアウトするには、Main.cpp の "サンプル使用状況テレメトリ" というラベルの付いたコードのブロックを削除します。

Microsoft のプライバシー ポリシー全般の詳細については、「[Microsoft のプライバシーに関する声明](https://privacy.microsoft.com/en-us/privacystatement/)」を参照してください。


