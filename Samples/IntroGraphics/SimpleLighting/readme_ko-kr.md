![](./media/image1.png)

# 단순 조명 샘플

*이 샘플은 Microsoft 게임 개발 키트와 호환 가능합니다(2020년 6월).*

# 설명

이 샘플은 정적 Direct3D 12 버텍스, 인덱스 및 상수 버퍼를 생성하고 정적 및 동적 Lambertian 조명을 사용하여 인덱스 처리된 지오메트리 리트를 가져오는 방법을 보여줍니다.

이 샘플에서는 두 개의 램프(각각 흰색 및 빨간색 정육면체)로 조명되는 큰 정육면체를 렌더링합니다. 흰색 램프는 정지 상태이고 빨간색 램프는 중앙 정육면체를 중심으로 궤도를 이동합니다. 또한 중앙 정육면체도 회전합니다. 이 동작을 통해 다양한 각도에서 유색 조명의 효과를 관찰할 수 있습니다.

![](./media/image3.png)

# 샘플 빌드

Xbox One 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.XboxOne.x64`(으)로 설정합니다.

Xbox One X|S 개발 키트를 사용하는 경우 활성 솔루션 플랫폼을 `Gaming.Xbox.Scarlett.x64`(으)로 설정합니다.

*자세한 내용은* *GDK 설명서의* __샘플 실행을__ 참조하세요.&nbsp;

# 샘플 사용

| 동작 | Gamepad |
|---|---|
| 끝내기 | 보기 버튼 |

# 구현 참고 사항

## 셰이더

## 이 샘플에서는 한 개의 꼭짓점 셰이더("TriangleVS")와 두 개의 픽셀 셰이더("LambertPS", "SolidColorPS")의 총 세 개 셰이더를 사용하여 장면을 렌더링합니다. 컴파일된 셰이더 Blob은 CreateDeviceDependentResources에 로드된 다음, 각 셰이더 조합에 대한 파이프라인 상태 개체를 만들 때 참조됩니다. 모든 셰이더는 동일한 HLSL 포함 파일인 "SimpleLighting.hlsli"에서 정의되며 세 개의 스텁 셰이더에 이 파일이 포함됩니다. 다른 진입점에 대해 각 스텁 셰이더는 세 개의 셰이더 Blob을 만들기 위해 컴파일됩니다.

## PSO(파이프라인 상태 개체)

단순 조명 샘플에는 두 가지 고유한 셰이더 조합이 있습니다. 하나는 LambertPS와 결합된 TriangleVS이고 다른 하나는 SolidColorPS와 결합된 TriangleVS입니다. DirectX 12에서는 모든 고유한 셰이더 조합에 대한 PSO(파이프라인 상태 개체)를 만들어야 합니다. 이름에서 알 수 있듯이 PSO는 특정 셰이더 집합을 사용하여 여러 그리기 호출에 필요한 모든 파이프라인 상태를 캡슐화합니다. PSO는 루트 서명, 파이프라인의 다양한 단계에 대한 셰이더, 래스터라이저 상태, 깊이 스텐실 상태, 혼합 상태 등과 같은 상태 설정을 결합합니다. (자세한 내용은 MSDN에 대한 설명서를 참조하세요.)

## 루트 서명

루트 서명은 그래픽 파이프라인에 바인딩된 리소스 유형과 리소스 배치 방법을 정의합니다. 루트 서명은 API 함수 서명과 비슷하며 매개 변수의 형식, 매개 변수 순서 및 레이아웃을 설명하지만 실제 매개 변수 인스턴스를 정의하지는 않습니다. 루트 매개 변수는 루트 서명의 요소에 해당하는 실제 데이터 인스턴스입니다. 샘플의 꼭짓점 셰이더는 셰이더 상수에 대한 단일 구조만 필요하므로 결과적으로 루트 서명은 매우 단순합니다. 루트 서명에는 ConstantBufferView 형식의 단일 루트 매개 변수가 포함되어 있습니다.

## 기하 도형

## 장면의 기하 도형은 정적 꼭짓점과 큐브의 6개 쿼드를 나타내는 24개의 꼭짓점 데이터를 포함하는 인덱스 배열로 구성됩니다. 두 배열은 Sample::CreateDeviceDependentResources 내에서 선언되며, 여기서 즉시 ID3D12Device::CreateCommittedResource에서 버퍼에 대한 ID3D12Resources를 만드는 데 사용됩니다. 샘플은 간단하게 D3D12_HEAP_TYPE_UPLOAD를 사용합니다. 한 단계만으로 데이터를 초기화는 동시에 각 리소스를 만들 수 있기 때문입니다. 하지만 \_UPLOAD 힙은 기하 도형 데이터에 최적의 위치는 아닙니다. 더 효율적인 구현에서는 기하 도형 데이터에 D3D12_HEAP_TYPE_DEFAULT를 사용합니다. \_DEFAULT 힙을 초기화하려면 \_UPLOAD 힙을 사용해야 하며, 결국 두 개의 힙을 사용함으로써 구현이 복잡해집니다.

기하 도형에 대한 버퍼가 만들어지면 샘플은 꼭짓점에 대해 D3D12_VERTEX_BUFFER_VIEW를 만들고 인덱스에 대해 D3D12_INDEX_BUFFER_VIEW를 만들 수 있습니다. 뷰는 ID3D12GraphicsCommandList::IASetVertextBuffer 및 ID3D12GraphicsCommandList::IASetVertextBuffer 호출을 통해 입력 어셈블러를 설정할 때 Sample::Render에서 사용됩니다.

## 셰이더 상수 관리

이 매우 간단한 장면에서는 모든 셰이더 상수가 다음을 포함하는 단일 상수 버퍼로 함께 일괄 처리됩니다.

- 월드, 뷰 및 프로젝션 매트릭스

- 조명 방향 및 색

- 단색

좀 더 복잡한 장면에서는 일반적으로 상수가 업데이트되는 빈도에 따라 상수를 여러 버퍼로 분할합니다.

큰 큐브와 빨간색 신호등은 애니메이션 효과가 적용되므로 그리기 호출 사이에 프레임당 셰이더 상수를 여러 번 업데이트해야 합니다. 루트 서명에는 각 그리기 호출에 사용할 셰이더 상수의 복사본을 참조해야 하는 ConstantBufferView 형식의 단일 루트 매개 변수가 포함되어 있습니다. CPU와 GPU는 병렬로 작동하므로 GPU는 GPU가 상수 버퍼 사용을 완료할 때까지 해당 버퍼를 업데이트하려고 시도해서는 안 됩니다. 단일 상수 버퍼만 있는 경우 상수를 여러 그리기 호출에 대해 업데이트해야 하므로 GPU가 그리기를 완료할 때까지 CPU는 차단되어야 합니다. 따라서 샘플은 여러 상수 버퍼를 사용하므로 GPU가 그리는 동안 CPU가 GPU에 상수를 계속 보낼 수 있습니다.

샘플은 간단하며 프레임당 고정된 수의 그리기 호출이 있으며, 이는 컴파일 때 알려집니다. 이 샘플은 스왑 체인의 백 버퍼 수를 곱하여 각 그리기 호출에 대해 하나의 버퍼를 만듭니다. 이 숫자는 CPU에서 쓸 수 있는 무료 버퍼가 항상 있도록 보장합니다. 모든 상수 버퍼는 Sample::CreateDeviceDependentResources에서 만든 단일 연속 업로드 버퍼에 저장됩니다. 업로드 버퍼는 CPU 주소 공간과 GPU 주소 공간 모두의 기본 메모리 주소를 가져오기 위해 즉시 매핑됩니다.

Sample::Render 메서드에서 상수는 상수 업로드 힙의 CPU 기본 주소에서 인덱싱된 위치에 기록됩니다. 동일한 인덱스를 GPU 주소와 결합하여 ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView 호출을 통해 버퍼를 파이프라인에 바인딩합니다. 인덱스는 그리기 수뿐만 아니라 백 버퍼 주기도 고려해야 합니다. 자세한 내용은 Sample::Render 구현을 참조하세요.

## CPU/GPU 동기화

CPU가 GPU에서 처리할 수 있는 것보다 더 빠르게 GPU에 명령 목록을 발행할 수 있는 경우 결국 CPU는 GPU가 따라잡을 때까지 기다려야 합니다. 이 샘플에서는 라운드 로빈 방식으로 상수 버퍼 메모리를 사용하며, 이는 버퍼 슬롯이 고정된 기간 후에 다시 사용됨을 의미합니다. 일반적으로 공유 리소스를 다시 사용하기 전에 일종의 동기화 전략을 사용하여 리소스가 사용 중이 아닌지 하는 것이 중요합니다. 샘플에서는 ID3D12Fence를 사용하여 CPU와 GPU를 동기화합니다. CPU는 명령 큐에 명령을 삽입하여 프레임 인덱스 값으로 펜스 개체 "신호"를 보냅니다. 그러면 GPU에서 신호 명령이 처리되는 즉시 제공된 프레임 인덱스 값이 CPU에 표시됩니다. 이렇게 하면 CPU가 현재 프레임 인덱스와 GPU에서 신호를 준 마지막 프레임 인덱스를 비교하여 GPU가 CPU와 비교해 뒤처지는지 확인할 수 있습니다. GPU 프레임 수와 CPU 프레임 수의 차이가 백 버퍼의 수를 넘는 경우 CPU가 기다려야 합니다.

# 개인정보처리방침

샘플을 컴파일하고 실행하는 경우 샘플 사용량을 추적할 수 있도록 샘플 실행 파일의 파일 이름이 Microsoft에 전송됩니다. 이 데이터 수집을 옵트아웃하려면 Main.cpp에서 "샘플 사용량 원격 분석"이라는 레이블이 지정된 코드 블록을 제거할 수 있습니다.

일반적인 Microsoft의 개인 정보 정책에 대한 자세한 내용은 [Microsoft 개인정보처리방침](https://privacy.microsoft.com/en-us/privacystatement/)을 참조하세요.


