![](./media/image1.png)

# Simple Lighting サンプル

*このサンプルは Microsoft Game Development Kit (2020 年 6 月) と互換性があります*

# 説明

このサンプルでは、静的 Direct3D 12 頂点、インデックス、および定数バッファーを作成し、静的および動的な Lambertian ライティングを使用してライティングされたインデックス付きジオメトリを描画する方法を示します。

このサンプルでは、2 つのライト (1 つの白と 1 つの赤) で照らされた大きな立方体をレンダリングします。これは、キューブとも表されます。 白のライトは、赤いライトが中央の立方体の周囲を周回している間、固定されています。 中央のキューブも回転します。 モーションを使用すると、さまざまな角度からカラー照明の効果を観察できます。

![](./media/image3.png)

# サンプルのビルド

Xbox One 開発キットを使用している場合は、アクティブなソリューション プラットフォームを `Gaming.Xbox.XboxOne.x64` に設定します。

Xbox One X|S 開発キットを使用している場合は、アクティブなソリューション プラットフォームを `Gaming.Xbox.Scarlett.x64` に設定します。

*詳細については、**GDK ドキュメント*の「__サンプルの実行__」 を参照してください。

# サンプルの使用方法

| 操作 | ゲームパッド |
|---|---|
| Exit | ビュー ボタン |

# 実装メモ

## シェーダー

## このサンプルでは、頂点シェーダー ("TriangleVS") と 2 つのピクセル シェーダー ("LambertPS"、"SolidColorPS") の 3 つのシェーダーを使用してシーンをレンダリングします。 コンパイルされたシェーダー BLOB は CreateDeviceDependentResources に読み込まれ、シェーダーの組み合わせごとにパイプライン状態オブジェクトを作成するときに参照されます。 すべてのシェーダーは同じ HLSL インクルード ファイル "SimpleLighting.hlsli" で定義され、3 つのスタブ シェーダーにこのファイルが含まれます。 各スタブ シェーダーは、3 つのシェーダー BLOB を作成するために、異なるエントリ ポイント用にコンパイルされます。

## パイプライン状態オブジェクト (PSO)

Simple Lighting サンプルには、2 つの固有のシェーダーの組み合わせがあります。1 つ目は TriangleVS と LambertPS の組み合わせ、2 つ目は TriangleVS と SolidColorPS です。 DirectX 12 では、一意のシェーダーの組み合わせごとにパイプライン状態オブジェクト (PSO) を作成する必要があります。 名前が示すように、PSO は、特定のシェーダーのセットを使用する複数の描画呼び出しに必要となるすべてのパイプライン状態をカプセル化します。 PSO は、ルート署名、パイプラインのさまざまなステージのシェーダー、ラスタライザーの状態、深度ステンシルの状態、ブレンド状態などの状態設定を組み合わせたものです。 (詳細については、MSDN のドキュメントをご覧ください。)

## ルート署名

ルート署名は、グラフィックス パイプラインにバインドされるリソースの種類と、リソースのレイアウト方法を定義します。 ルート署名は API 関数の署名に似ており、パラメーターの型、パラメーターの順序、レイアウトを記述しますが、実際のパラメーター インスタンスは定義しません。 ルート パラメーターは、ルート署名の要素に対応する実際のデータ インスタンスです。 サンプルの頂点シェーダーでは、シェーダー定数に必要な構造体は 1 つだけであるため、ルート署名は非常に単純になります。 ルート署名には、ConstantBufferView 型の単一のルート パラメーターが含まれています。

## 幾何学記号

## シーンのジオメトリは、立方体の 6 つの四角形を表す 24 個の頂点のデータを含む静的な頂点とインデックス配列で構成されます。 2 つの配列は Sample::CreateDeviceDependentResources 内で宣言されており、ID3D12Device::CreateCommittedResource によってすぐに使用されて、バッファー用の ID3D12Resources が作成されます。 わかりやすくするために、サンプルでは D3D12_HEAP_TYPE_UPLOAD を使用します。これにより、単一の手順でデータを使用して各リソースを初期化しながら各リソースを作成できるためです。 ただし、\_UPLOAD ヒープはジオメトリ データの最適な場所ではありません。 より効率的な実装では、ジオメトリ データの D3D12_HEAP_TYPE_DEFAULT を使用します。 \_DEFAULT ヒープを初期化するには、\_UPLOAD ヒープを使用する必要があるため、最終的に 2 つのヒープを使用することになり、実装が複雑になります。

ジオメトリのバッファーが作成されると、サンプルは頂点のD3D12_VERTEX_BUFFER_VIEW とインデックスの D3D12_INDEX_BUFFER_VIEW を作成できます。 ビューは、ID3D12GraphicsCommandList::IASetVertextBuffer と ID3D12GraphicsCommandList::IASetVertextBuffer の呼び出しを使用して入力アセンブラーを設定するときに Sample::Render で使用されます。

## シェーダー定数の管理

この非常に単純なシーンでは、すべてのシェーダー定数が、次を含む単一の定数バッファーにまとめられています。

- ワールド、ビュー、プロジェクション マトリックス

- ライトの方向と色

- 単色

より複雑なシーンの場合は、通常、定数が更新される頻度に応じて、定数を複数のバッファーに分割します。

大きな立方体と赤いライトがアニメーション化されるため、シェーダー定数は描画呼び出しの間にフレームごとに複数回更新する必要があります。 ルート署名には、各描画呼び出しで使用するシェーダー定数のコピーを参照する必要がある ConstantBufferView 型の単一のルート パラメーターが含まれていることを思い出してください。 CPU と GPU は並列で動作するため、GPU が定数バッファーを使用するまで、CPU は定数バッファーの更新しようとすべきではありません。 定数バッファーが 1 つしかない場合、GPU が描画を完了するまで CPU はブロックする必要があります。これは、複数の描画呼び出しに対して定数を更新する必要があるため、非現実的です。 したがって、サンプルでは複数の定数バッファーを使用して、GPU の描画中に CPU が GPU に定数を送信し続けることができます。

サンプルは単純で、フレームあたりの描画呼び出しの数が固定されており、コンパイル時に認識されます。 このサンプルでは、描画呼び出しごとに 1 つのバッファーをスワップ チェーン内のバック バッファーの数で乗算して作成します。 この数は、CPU が書き込むための空きバッファーが常に存在することが保証されます。 すべての定数バッファーは、Sample::CreateDeviceDependentResources で作成された単一の連続したアップロード バッファーに格納されます。 アップロード バッファーはすぐにマップされ、CPU アドレス空間と GPU アドレス空間の両方のベース メモリ アドレスが取得されます。

Sample::Render メソッドでは、定数は、定数アップロード ヒープの CPU ベース アドレスからインデックスが付けられた場所に書き込まれます。 同じインデックスを GPU アドレスと組み合わせて、ID3D12GraphicsCommandList::SetGraphicsRootConstantBufferView を呼び出してバッファーをパイプラインにバインドします。 インデックスは、描画カウントだけでなくバック バッファーの頻度も考慮する必要があります。 詳細については、Sample::Render の実装を参照してください。

## CPU/GPU の同期

GPU がコマンド リストを処理するよりも早く CPU が GPU にコマンド リストを発行できる場合、最終的に CPU は GPU が追いつくのを待つ必要があります。 このサンプルでは、ラウンドロビン方式で定数バッファー メモリを使用します。これは、バッファー スロットが一定期間後に再利用されることを意味します。 一般に、共有リソースを再利用する前に、何らかの同期戦略を使用して、リソースが使用中でないことを確認することが重要です。 このサンプルでは、ID3D12Fence を使用して CPU と GPU を同期します。 CPU はコマンド キューにコマンドを挿入して、フレーム インデックス値を持つフェンス オブジェクトに "シグナル" を送ります。 シグナル コマンドが GPU で処理されるとすぐに、提供されたフレーム インデックス値が CPU に表示されるようになります。 これにより、CPU は現在のフレーム インデックスと GPU によってシグナル通知された最後のフレーム インデックスを比較して、GPU が CPU と比較してどれだけ遅れているかを判断できるようになります。 GPU フレーム数と CPU フレーム数の差がバック バッファーの数を超える場合、CPU は待機する必要があります。

# プライバシーに関する声明

サンプルをコンパイルして実行する場合、サンプルの使用状況を追跡するために、サンプルの実行可能ファイルのファイル名が Microsoft に送信されます。 このデータ コレクションからオプトアウトするには、Main.cpp の "サンプル使用状況テレメトリ" というラベルの付いたコードのブロックを削除します。

Microsoft のプライバシー ポリシー全般の詳細については、「[Microsoft のプライバシーに関する声明](https://privacy.microsoft.com/en-us/privacystatement/)」を参照してください。


